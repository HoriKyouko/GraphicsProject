<!DOCTYPE html>
<!--Created By: Steven Michael Zielinski-->
<!--For: CAP5725 Assignment 5 -->
<!--When running the project the first model shown is with the correct 
    material. Clicking the threejs checkbox will show the 
    MeshPhongMaterial model and deselecting it will show my fragment
    and vertex shaders with the same settings.-->

<html>
    <head>
        <title>--Assignment 5 Irradiance--</title>
        <script src="https://threejs.org/build/three.js"></script>
        <script 
            src=
            "https://threejs.org/examples/js/controls/OrbitControls.js">
        </script>
        <script 
            src="https://threejs.org/examples/js/libs/dat.gui.min.js">
        </script>
        <script
            src="https://threejs.org/examples/js/loaders/OBJLoader.js">
        </script>
        <script
            src="https://threejs.org/examples/js/loaders/MTLLoader.js">
        </script>
        <script>
            "use strict";

            // This file was copied directly from addObjToScene which 
            // was given by the professor. I have only added in spacing to 
            // make it easier to read.
            // The method loads an OBJ file whose detail is specified in 
            // objectInfo
            // File is loaded asynchronously
            // After loading the model is normalized (scaled to make maximum 
            // base width to 1
            // Adds it into "scene"
            // Applies scaling and translation
            // Invokes the "render" function at the end.

            // Parameters:
            // objectInfo: an object with the following properties:
            //          mtlPathName : path to the directory for obj file. 
            //              default: "./"
            //          objPathName : path to the directory for obj file. 
            //              default: "./"
            //          texturePathName :  path to the directory for texture. 
            //              default: "./"
            //          mtlFileName : material file name. default: "null"
            //          objFileName : "suzanne.obj",
            //          scale: scalefactor to uniformly scale the object. 
            //              detault=1
            //          y_rotate: rotation angle in radian. Default = 0
            //          translateVector: a translation vector: default = new 
            //              THREE.Vector3(0,0,0),
            //          obj: undefined
            //
            // "scene": The scene object to which the loaded object mesh is 
            //      added.
            // "render": the render function to render the scene.
            // example use:
            /*
                let suzanne = {
                    mtlPathName : "./objModels/suzanne/",
                    objPathName : "./objModels/suzanne/",
                    texturePathName : "./objModels/suzanne/",
                    mtlFileName : "suzanne.mtl",
                    objFileName : "suzanne.obj",
                    scale: 10,
                    y_rotate: 0,
                    translateVector: new THREE.Vector3(0,0,0),
                    obj: undefined
                };
                addObjToSceneAndRender(suzanne, scene, render)
            */
            function addObjToSceneAndRender(objectInfo, scene, render) 
            {

                if (!objectInfo.objFileName) 
                {
                    console.log(objectInfo)
                    console.log("Missing Object file");
                }
                
                let objLoader = new THREE.OBJLoader();
                
                if (objectInfo.objPathName) 
                {
                    objLoader.setPath(objectInfo.objPathName);
                }
                
                if (objectInfo.mtlPathName) 
                {
                    let mtlLoader = new THREE.MTLLoader();
                    mtlLoader.setPath(objectInfo.mtlPathName);
                    
                    if (objectInfo.texturePathName)
                    {
                        mtlLoader.setTexturePath(objectInfo.texturePathName);
                    }
                    
                    mtlLoader.load(objectInfo.mtlFileName, onMtlLoad);
                }
                else 
                {
                    objLoader.load(objectInfo.objFileName, onObjLoad);
                }
                    
                function onMtlLoad(mtl) 
                {
                    mtl.preload();
                    objLoader.setMaterials(mtl);
                    objLoader.load(objectInfo.objFileName, onObjLoad);
                }

                // called when resource is loaded
                function onObjLoad(object) 
                {
                    //object.children.forEach(function(e){e.material = normalMaterial;});
                    let bBox = new THREE.Box3().setFromObject(object);
                    let size = new THREE.Vector3();
                    bBox.getSize(size);
                    let maxBaseSize = Math.max(size.x, size.z);
                    let scaleFactor = 
                        ((objectInfo.scale)?objectInfo.scale:1)/ maxBaseSize;
                    object.scale.multiplyScalar(scaleFactor);
                    
                    if (objectInfo.y_rotate) 
                    {
                        object.rotateY(objectInfo.y_rotate);
                    }
                    
                    if (objectInfo.translateVector) 
                    {
                        object.position.copy(objectInfo.translateVector);
                    }

                    objectInfo.obj = object;
                    scene.add(object);
                    render();
                }
            }

            // This file was copied directly from addObjToScene which 
            // was given by the professor. I have only added in spacing to 
            // make it easier to read.
            function updateObjectMaterial(object, material)
            {
                console.log(object);

                if (object.material) 
                {
                    object.material = material;
                }
	            else if (object.children)
		        {
                    object.children.forEach(
                        function(e){e.material = material;});
                }
                else 
                {
                    alert("Error: Object does not have material property.");
                }
            }

            function readFromFile(filename)
            {
                // Create a http request
                var	xmlhttp = new XMLHttpRequest();
                
                // Open the file
                xmlhttp.open("GET", filename, false);

                // 
                xmlhttp.overrideMimeType("application/document");

                // 
                xmlhttp.send(null);

                // Return the text
                return xmlhttp.responseText;
            }

            // This function converts a texture into image data that can 
            // have the color value of individual pictures accessed
            function getImageData (tex) 
            {
                let image = tex.image;

                let canvas = document.createElement('canvas');
                canvas.width = image.width;
                canvas.height = image.height;

                let context = canvas.getContext('2d');
                context.drawImage(image, 0, 0);

                return context.getImageData(0, 0, image.width, image.height);
            }

            // This function allows us to get the data of a single pixel from 
            // the texture image being used for the environment
            function getPixel(imageData, x, y)
            {
                let position = (x + imageData.width * y) * 4;
                let data = imageData.data;
                
                return { r: data[position], g: data[position + 1], 
                    b: data[position + 2], a: data[position + 3]};
            }

            // The location of the lambertian surface
            let P = new THREE.Vector3(0.0, 0.0, 0.0);
            
            // The change in the normal based on degrees of angle
            let deltaTheta = 1.0;
            let deltaPhi = 1.0;

            // The change in the barycentric coordinates
            let du = 0.1;
            let dv = 0.1;

            let imageData = new Array();

            let myMaterial;

            function mainFunction()
            {
                // Setup the renderer
                let renderer = new THREE.WebGLRenderer();
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);

                // Create the scene
                let scene = new THREE.Scene();

                // Find the aspect ratio of the window
                let aspect = window.innerWidth / window.innerHeight;
                // Setup the camera for perspective viewing
                let camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 100);
                camera.position.z = 20;
                scene.add(camera);

                console.log(readFromFile("Assignment5.vs"));
                console.log(readFromFile("Assignment5-1.fs"));

                document.body.appendChild( renderer.domElement );

                // Render function to draw the scene
                let render = function()
                {
                    renderer.render(scene, camera);
                };

                // Add the object to the scene
                let bunny = {
                    objPathName : "./",
                    objFileName : "bunny.obj",
                    scale: 10,
                    y_rotate: 0,
                    translateVector: new THREE.Vector3(0,0,0),
                    obj: undefined
                };
                addObjToSceneAndRender(bunny, scene, render);

                console.log(bunny);
                console.log(bunny.obj);

                updateObjectMaterial(bunny.obj, myMaterial);

                // Setup for the camera controls that allow the user
                // to move the camera
                let cameraControl = new THREE.OrbitControls(camera);
                cameraControl.addEventListener("change", render);

                window.addEventListener( 'resize', onWindowResize, false );

                function onWindowResize()
                {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();

                    renderer.setSize(window.innerWidth, window.innerHeight);

                    render();
                }

                render();
            }


            let imgTexture = new THREE.CubeTextureLoader().load(
                ['./neg-x.png', './neg-y.png', './neg-z.png',
                './pos-x.png', './pos-y.png', './pos-z.png'],
                function getImageData(tex)
                {
                    for (let i = 0; i < 6; i++)
                    {
                        let image = tex.image[i];

                        let canvas = document.createElement('canvas');
                        canvas.width = image.width;
                        canvas.height = image.height;

                        let context = canvas.getContext('2d');
                        context.drawImage(image, 0, 0);

                        imageData[i] = context.getImageData(0, 0, 
                        image.width, image.height);
                    }

                    console.log("Loaded all images");

            // Create the four points of the different faces
            // These will change in the switch statement based on the side of 
            // the cube
            let A = new THREE.Vector3(0.0, 0.0, 0.0);
            let B = new THREE.Vector3(0.0, 0.0, 0.0);
            let C = new THREE.Vector3(0.0, 0.0, 0.0);
            let D = new THREE.Vector3(0.0, 0.0, 0.0);

            // Create the cube normal that will also change based on the side
            // being considered
            let faceNormal = new THREE.Vector3(0.0, 0.0, 0.0);

            // Create the irradiance light map that will be printed at the end 
            // of the program
            let lightMap = new Array();
            for (let phi = 0; phi < 360; phi += deltaPhi)
            {
                lightMap[phi] = new Array();
                for (let theta = 0; theta < 180; theta += deltaTheta)
                {
                    lightMap[phi][theta] = new THREE.Vector4();
                }
            }

            let AB = new THREE.Vector3();
            let AD = new THREE.Vector3();

            // This will loop through every image in order to sum up the values
            for (let curImage = 0; curImage < 6; curImage++)
            {
                // Create the points and the normals for the cube faces
                switch (curImage)
                {
                    case 0:
                        // Create the four points of the square
                        A.x = -1.0; A.y = -1.0; A.z = 1.0;
                        B.x = -1.0; B.y = -1.0; B.z = -1.0;
                        C.x = -1.0; C.y = 1.0; C.z = -1.0;
                        D.x = -1.0; D.y = 1.0; D.z = 1.0;

                        // Create the normal using the cross product
                        AB = new THREE.Vector3(A.x - B.x, A.y - B.y, 
                            A.z - B.z);
                        AD = new THREE.Vector3(A.x - D.x, A.y - D.y, 
                            A.z - D.z);

                        faceNormal = AB.clone().cross(AD);

                        // Make sure the normal is normalized
                        faceNormal = faceNormal.normalize();
                        break;
                    case 1:
                        // Create the four points of the square
                        A.x = -1.0; A.y = -1.0; A.z = 1.0;
                        B.x = 1.0; B.y = -1.0; B.z = 1.0;
                        C.x = 1.0; C.y = -1.0; C.z = -1.0;
                        D.x = -1.0; D.y = -1.0; D.z = -1.0;

                        // Create the normal using the cross product
                        AB = new THREE.Vector3(A.x - B.x, A.y - B.y, 
                            A.z - B.z);
                        AD = new THREE.Vector3(A.x - D.x, A.y - D.y, 
                            A.z - D.z);

                        faceNormal = AB.clone().cross(AD);

                        // Make sure the normal is normalized
                        faceNormal = faceNormal.normalize();
                        break;
                    case 2:
                        // Create the four points of the square
                        A.x = -1.0; A.y = -1.0; A.z = -1.0;
                        B.x = 1.0; B.y = -1.0; B.z = -1.0;
                        C.x = 1.0; C.y = 1.0; C.z = -1.0;
                        D.x = -1.0; D.y = 1.0; D.z = -1.0;

                        // Create the normal using the cross product
                        AB = new THREE.Vector3(A.x - B.x, A.y - B.y, 
                            A.z - B.z);
                        AD = new THREE.Vector3(A.x - D.x, A.y - D.y, 
                            A.z - D.z);

                        faceNormal = AB.clone().cross(AD);

                        // Make sure the normal is normalized
                        faceNormal = faceNormal.normalize();
                        break;
                    case 3:
                        // Create the four points of the square
                        A.x = 1.0; A.y = -1.0; A.z = 1.0;
                        B.x = 1.0; B.y = -1.0; B.z = -1.0;
                        C.x = 1.0; C.y = 1.0; C.z = -1.0;
                        D.x = 1.0; D.y = 1.0; D.z = 1.0;

                        // Create the normal using the cross product
                        AB = new THREE.Vector3(A.x - B.x, A.y - B.y, 
                            A.z - B.z);
                        AD = new THREE.Vector3(A.x - D.x, A.y - D.y, 
                            A.z - D.z);

                        faceNormal = AB.clone().cross(AD);

                        // Make sure the normal is normalized
                        faceNormal = faceNormal.normalize();
                        break;
                    case 4:
                        // Create the four points of the square
                        A.x = -1.0; A.y = 1.0; A.z = -1.0;
                        B.x = 1.0; B.y = 1.0; B.z = -1.0;
                        C.x = 1.0; C.y = 1.0; C.z = 1.0;
                        D.x = -1.0; D.y = 1.0; D.z = 1.0;

                        // Create the normal using the cross product
                        AB = new THREE.Vector3(A.x - B.x, A.y - B.y, 
                            A.z - B.z);
                        AD = new THREE.Vector3(A.x - D.x, A.y - D.y, 
                            A.z - D.z);

                        faceNormal = AB.clone().cross(AD);

                        // Make sure the normal is normalized
                        faceNormal = faceNormal.normalize();
                        break;
                    case 5:
                        // Create the four points of the square
                        A.x = -1.0; A.y = -1.0; A.z = 1.0;
                        B.x = 1.0; B.y = -1.0; B.z = 1.0;
                        C.x = 1.0; C.y = 1.0; C.z = 1.0;
                        D.x = -1.0; D.y = 1.0; D.z = 1.0;

                        // Create the normal using the cross product
                        AB = new THREE.Vector3(A.x - B.x, A.y - B.y, 
                            A.z - B.z);
                        AD = new THREE.Vector3(A.x - D.x, A.y - D.y, 
                            A.z - D.z);

                        faceNormal = AB.clone().cross(AD);

                        // Make sure the normal is normalized
                        faceNormal = faceNormal.normalize();
                        break;
                }
                // All Points for the images of the cube faces have been created

                // Go through the current face using barycentric coordinates
                // Also since there is 2 triangles 2 points will be handled 
                // simultaneously
                for (let u = 0.0; u < 1.0; u += du)
                {
                    for (let v = 0.0; v < (1.0 - u); v += dv)
                    {
                        let facePointOne = A.clone().multiplyScalar(1.0 - u - v).add(B.clone().multiplyScalar(u).add(C.clone().multiplyScalar(v)));
                        let facePointTwo = A.clone().multiplyScalar(1.0 - u - v).add(C.clone().multiplyScalar(u).add(D.clone().multiplyScalar(v)));;

                        // These will be the colors from the image face being
                        // used
                        let colorP1 = new THREE.Vector4();
                        let colorP2 = new THREE.Vector4();

                        let x1 = 0.0;
                        let x2 = 0.0;

                        let y1 = 0.0;
                        let y2 = 0.0;

                        // Get the converted coordinates from the image
                        switch (curImage)
                        {
                            case 0:
                                // I add 1 in order to make the values zero 
                                // based so the values go from 0-2. I then 
                                // divide by 2 in order to go from 0-1. Then 
                                // multiply by the width or height to find 
                                // the pixel image value.
                                x1 = (facePointOne.z + 1.0) / 2.0 * 
                                    imageData[curImage].width;  
                                x2 = (facePointTwo.z + 1.0) / 2.0 * 
                                    imageData[curImage].width;
                                y1 = (facePointOne.y + 1.0) / 2.0 * 
                                    imageData[curImage].height;
                                y2 = (facePointTwo.y + 1.0) / 2.0 * 
                                    imageData[curImage].height;
                                break;
                            case 1:
                                // I add 1 in order to make the values zero 
                                // based so the values go from 0-2. I then 
                                // divide by 2 in order to go from 0-1. Then 
                                // multiply by the width or height to find 
                                // the pixel image value.
                                x1 = (facePointOne.x + 1.0) / 2.0 * 
                                    imageData[curImage].width;  
                                x2 = (facePointTwo.x + 1.0) / 2.0 * 
                                    imageData[curImage].width;
                                y1 = (facePointOne.z + 1.0) / 2.0 * 
                                    imageData[curImage].height;
                                y2 = (facePointTwo.z + 1.0) / 2.0 * 
                                    imageData[curImage].height;
                                break;
                            case 2:
                                // I add 1 in order to make the values zero 
                                // based so the values go from 0-2. I then 
                                // divide by 2 in order to go from 0-1. Then 
                                // multiply by the width or height to find 
                                // the pixel image value.
                                x1 = (facePointOne.x + 1.0) / 2.0 * 
                                    imageData[curImage].width;  
                                x2 = (facePointTwo.x + 1.0) / 2.0 * 
                                    imageData[curImage].width;
                                y1 = (facePointOne.y + 1.0) / 2.0 * 
                                    imageData[curImage].height;
                                y2 = (facePointTwo.y + 1.0) / 2.0 * 
                                    imageData[curImage].height;
                                break;
                            case 3:
                                // I add 1 in order to make the values zero 
                                // based so the values go from 0-2. I then 
                                // divide by 2 in order to go from 0-1. Then 
                                // multiply by the width or height to find 
                                // the pixel image value.
                                x1 = (facePointOne.z + 1.0) / 2.0 * 
                                    imageData[curImage].width;  
                                x2 = (facePointTwo.z + 1.0) / 2.0 * 
                                    imageData[curImage].width;
                                y1 = (facePointOne.y + 1.0) / 2.0 * 
                                    imageData[curImage].height;
                                y2 = (facePointTwo.y + 1.0) / 2.0 * 
                                    imageData[curImage].height;
                                break;
                            case 4:
                                // I add 1 in order to make the values zero 
                                // based so the values go from 0-2. I then 
                                // divide by 2 in order to go from 0-1. Then 
                                // multiply by the width or height to find 
                                // the pixel image value.
                                x1 = (facePointOne.x + 1.0) / 2.0 * 
                                    imageData[curImage].width;  
                                x2 = (facePointTwo.x + 1.0) / 2.0 * 
                                    imageData[curImage].width;
                                y1 = (facePointOne.z + 1.0) / 2.0 * 
                                    imageData[curImage].height;
                                y2 = (facePointTwo.z + 1.0) / 2.0 * 
                                    imageData[curImage].height;
                                break;
                            case 5:
                                // I add 1 in order to make the values zero 
                                // based so the values go from 0-2. I then 
                                // divide by 2 in order to go from 0-1. Then 
                                // multiply by the width or height to find 
                                // the pixel image value.
                                x1 = (facePointOne.x + 1.0) / 2.0 * 
                                    imageData[curImage].width;  
                                x2 = (facePointTwo.x + 1.0) / 2.0 * 
                                    imageData[curImage].width;
                                y1 = (facePointOne.y + 1.0) / 2.0 * 
                                    imageData[curImage].height;
                                y2 = (facePointTwo.y + 1.0) / 2.0 * 
                                    imageData[curImage].height;
                                break;
                        }
                        // We now have the texture coordinates in order to get
                        // the color from the image

                        // Get the colors from the images
                        colorP1 = getPixel(imageData[curImage], x1, y1);
                        colorP2 = getPixel(imageData[curImage], x2, y2);

                        // Convert the colors into a vector 4 to be used in 
                        // calculations
                        let color1 = new THREE.Vector4(
                            colorP1.r, colorP1.g, colorP1.b, colorP1.a);
                        let color2 = new THREE.Vector4(
                            colorP2.r, colorP2.g, colorP2.b, colorP2.a);

                        // These loops will allow us to find the color value for
                        // each normal
                        for (let phi = 0; phi < 360; phi += deltaPhi)
                        {
                            for (let theta = 0; theta < 180; 
                                theta += deltaTheta)
                            {
                                let radTheta = theta / 180.0;
                                let radPhi = phi / 180.0;

                                // Create the fragment normal that will be used
                                // for this angle
                                let fragNormal = new THREE.Vector3(
                                    Math.cos(radPhi) * Math.sin(radTheta),
                                    Math.sin(radPhi) * Math.sin(radTheta),
                                    Math.cos(radTheta));
                                fragNormal = fragNormal.normalize();
                                
                                // This can be done since the fragment point is 
                                // 0, 0, 0
                                let LtoFrag1 = facePointOne.clone().normalize();
                                let LtoFrag2 = facePointTwo.clone().normalize();
                                let FragtoL1 = 
                                    facePointOne.clone().negate().normalize();
                                let FragtoL2 = 
                                    facePointTwo.clone().negate().normalize();

                                // Calculate the distance between the fragment
                                // and the current part of the area
                                let distance1 = 
                                    facePointOne.x * facePointOne.x + 
                                    facePointOne.y * facePointOne.y + 
                                    facePointOne.z * facePointOne.z;
                                let distance2 = 
                                    facePointTwo.x * facePointTwo.x + 
                                    facePointTwo.y * facePointTwo.y + 
                                    facePointTwo.z * facePointTwo.z;

                                // Get the cos(theta) for the fragment and the 
                                // area light source
                                let fragDot1 = Math.max(Math.min(
                                    fragNormal.dot(FragtoL1), 1.0), 0.0);
                                let fragDot2 = Math.max(Math.min(
                                    fragNormal.dot(FragtoL2), 1.0), 0.0);
                                let areaDot1 = Math.max(Math.min(
                                    faceNormal.dot(LtoFrag1), 1.0), 0.0);
                                let areaDot2 = Math.max(Math.min(
                                    faceNormal.dot(LtoFrag2), 1.0), 0.0);

                                // I know this should be a jacobian in order to 
                                // account for non flat surfaces but this 
                                // environment light map doesn't require that
                                // since it is a flat surface
                                let deltaArea = du * dv;

                                lightMap[phi][theta] = 
                                    lightMap[phi][theta].add(
                                    color1.clone().multiplyScalar((fragDot1 * 
                                    areaDot1 / distance1) * deltaArea * 
                                    AB.clone().cross(AD).length()));
                                
                                lightMap[phi][theta] = 
                                    lightMap[phi][theta].add(
                                    color2.clone().multiplyScalar((fragDot2 * 
                                    areaDot2 / distance2) * deltaArea * 
                                    AB.clone().cross(AD).length()));
                            }// end theta
                        }// end phi
                    }// end v
                }// end u
            }// end cur image

            console.log(lightMap);

            let lightMapData = new Uint8Array(4 * 360 * 180);

            let location = 0;

            for (let phi = 0; phi < 360; phi += deltaPhi)
            {
                for (let theta = 0; theta < 180; theta += deltaTheta)
                {
                    lightMapData[location] = lightMap[phi][theta].r;
                    lightMapData[location+1] = lightMap[phi][theta].g;
                    lightMapData[location+2] = lightMap[phi][theta].b;
                    lightMapData[location+3] = lightMap[phi][theta].a;

                    location += 4;
                }
            }

            console.log(lightMapData);

            let dataTexture = new THREE.DataTexture(lightMapData, 180, 360, 
                THREE.RGBAFormat);

            myMaterial = new THREE.RawShaderMaterial(
            {
                side: THREE.DoubleSide,
                uniforms:{
                    texture: dataTexture,
                    diffuseColor: { value: new THREE.Color(0xffffff) }
                }, 
                fragmentShader:
                    readFromFile('Assignment5-1.fs'),
                vertexShader:
                    readFromFile('Assignment5.vs')
            });

                });
        </script>
    </head>
    <body onload=mainFunction();></body>
</html>